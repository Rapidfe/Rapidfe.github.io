---
title: 구간합, 세그먼트 트리
author: rapidfe
date: 2021-03-04 19:51:00 +0900
categories: [알고리즘]
tags: [자료구조, segment tree]
math: true
---

# **개요**

---

#### **이게 뭔가?**

세그먼트 트리(Segment tree)는 구간합을 구할 때 용이한 이진 트리(Binary tree) 형태의 자료 구조다. 리프 노드에 구간합을 구할 데이터가 저장되어 있고, 부모 노드에 자식 노드 전체를 포괄하는 합이 저장되어 있다.

#### **왜 쓰는가?**

그저 구간합을 위해서라면 굳이 세그먼트 트리를 사용할 필요가 없다. 세그먼트 트리는 구간합 뿐만 아니라 데이터의 갱신과 갱신된 구간합의 연산도 빠르게 처리할 수 있다.

# **구현**

---

구간합 배열 변수=\\(arr\\),　\\(arr\\)배열의 크기=\\(N\\),　세그먼트 트리 배열 변수=\\(tree\\)

#### **메모리 할당**

세그먼트 트리는 포화 이진 트리(Perfect binary tree)에 가깝다. '가깝다'라고 표현하는 이유는 \\(N\\)값이 \\(2^k\\)꼴이 아닌 이상 마지막 레벨이 모두 채워질 수 없으며, 구현 방식에 따라 비게 되는(0으로 채우는) 리프 노드가 조금 다르기 때문이다. 어쨌든 포화 이진 트리에 가깝기 때문에 세그먼트 트리는 1차원 배열로 구현하는 것이 좋다. 그렇다면 가장 먼저 고려할 것은 배열의 크기를 얼마로 지정할 것인가 이다.

1. \\(2^k\\)값이 \\(N\\) 이상이 되게 하는 \\(k\\)의 최솟값을 구한다.

   이 때의 \\(2^k\\)이 리프 노드의 갯수고 \\(2^k-1\\)이 리프 노드가 아닌 모든 노드의 갯수이다.

2. 구현을 쉽게 하기 위해 루트 노드를 \\(arr\\)의 1번 인덱스부터 시작하기로 한다.

   어떤 노드 \\(i\\)인덱스의 자식 노드 인덱스는 \\(i/times 2\\), \\(i/times 2+1\\)이 되는 규칙을 가진다.

따라서 \\(tree\\)배열의 크기는 \\(\ 2^k\ +\ 2^k-1\ +\ 1\ =\ 2·2^k\\) 로 지정하면 된다.

이 과정이 귀찮다면 \\(N\times4\\)를 해도 된다. 약간의 메모리 낭비가 있지만 이는 \\(2·2^k\\)보다 무조건 크기 때문이다.

#### **구현할 함수**

구현할 함수는 다음과 같다.

- 데이터 수정 함수 (Update)
- 데이터 질의 함수 (Query)
- 트리 구성 함수 (Construct)

Construct함수는 Query함수로 기능을 대체할 수 있으며 유의미하게 성능을 향상시키는 경우가 적기 때문에 생략하기도 한다.

#### **방식1) Bottom-up**

최하단 리프 노드부터 위로 연산하는 방식이다.

반복문을 사용하기 때문에 Top-down에 비해 단순하고 성능도 뛰어나다.

트리에 대해 이해하고 있다면 구현하기가 대체로 어렵지 않지만 Query함수는 이해하기가 약간 어려웠다. Query함수의 알고리즘은 다음과 같다. 먼저 2가지 규칙을 숙지해야 한다.

- 부모 노드의 왼쪽 자식 노드는 부모 노드 구간의 왼쪽 절반 구간을 가진다.

  -> 왼쪽 자식 노드의 부모 노드로 올라가면 자식 노드의 구간이 오른쪽으로 확장된다.

- 같은 이유로, 오른쪽 자식 노드의 부모 노드로 올라가면 자식 노드의 구간이 왼쪽으로 확장된다.

1. 구간합의 범위(\\(L~R\\)) 인덱스를 입력받는다.

2. 최하단 레벨에서부터 위로 탐색한다.

3. \\(L\\)이 오른쪽 자식 노드라면(인덱스 번호가 홀수라면) 해당 노드값을 합산하고 \\(L\\)에 1을 더한다.

   \\(L\\) 인덱스보다 왼쪽 값은 필요 없으므로 오른쪽 자식 노드의 부모 노드(왼쪽으로 확장)는 탐색할 필요가 없다. \\(L\\)에 1을 더한 뒤 상위 레벨로 올라가면 된다.

4. 동시에 같은 방식으로 \\(R\\) 인덱스도 탐색한다.

   \\(R\\)이 왼쪽 자식 노드라면(인덱스 번호가 짝수라면) 해당 노드값을 합산하고 \\(R\\)에 1을 뺀다.

5. L\\(\geq\\)R이 될 때까지 반복한다.

\\("\\)L에(또는 R에) 1을 더하고(빼고) 상위 레벨로 올라갈 때, 입력받은 범위보다 더 오른쪽까지(왼쪽까지) 포함하는 노드가 나오진 않을까?\\(\textrm"\\) 와 같은 의문을 처음에 가졌지만 아니었다. 필요없는 구간을 계속 쳐내면서, L과 R이 동시에 구간을 좁히며 탐색하기 때문에 그런 일이 발생하기 전에 반복문이 종료된다.

{%raw%}

```c++
#include <iostream>
#include <vector>

using namespace std;

int arr[] = {2,5,-1,20,12,-13,-4,2,14};
int N,capacity;
vector<int> tree;

void update(int idx, int data){
    int i = capacity + idx;
    tree[i] = data;
    for(i=i/2; i>0; i/=2)
        tree[i] = tree[i*2] + tree[i*2+1];
}

int query(int L, int R){
    L += capacity;
    R += capacity;
    int sum = 0;
    for(; L<R; L/=2,R/=2){
        if( L%2==1 ) sum += tree[L++];
        if( R%2==0 ) sum += tree[R--];
    }
    if( L==R ) sum += tree[L];
    return sum;
}

vector<int> construct(){
    N = sizeof(arr)/sizeof(int);
    for(capacity=1; capacity<N; capacity*=2);

    vector<int> new_tree(2*capacity);
    int i;
    for(i=capacity; i<capacity+N; i++)
        new_tree[i] = arr[i-capacity];
    for(; i<capacity*2; i++)
        new_tree[i] = 0;
    for(i=capacity-1; i>0; i--)
        new_tree[i] = new_tree[i*2] + new_tree[i*2+1];
    return new_tree;
}

int main(){
    tree = construct();
    cout<<tree[1]<<" "<<query(1,4)<<"\n";
    update(2, 3);
    cout<<tree[1]<<" "<<query(1,4)<<"\n";
    return 0;
}
```

{%endraw%}

> [[MST 알고리즘을 참고한 블로그]](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html)

#### **오답 1**

격자의 가로, 세로 크기가 다를 수 있음을 고려하지 않아 가로, 세로 탐색 시 반복문의 범위 설정을 잘못함.

#### **오답 2**

시뮬레이션 도중 continue문을 잘못 사용함. continue하기 전에 해야할 걸 다 했는지 확인해야 됨.



# **코드**

---

```c++
#include <stdio.h>
#include <queue>

using namespace std;

typedef struct{int r,c;}coo;
typedef struct{int node,w;}st;
int ga,se,nodes;
int arr[10][10];
int dr[] = {0,1,0,-1}, dc[] = {1,0,-1,0};
queue<coo> qu;
vector<st> edges[8];

coo fmove(coo now, int dir){
    now.r += dr[dir];
    now.c += dc[dir];
    if( now.r<0 || now.r==se || now.c<0 || now.c==ga )
        now.r = -1;
    return now;
}

void make_nodes(){
    int cnt = 2;
    coo now,next;
    for(int i=0; i<se; i++){
        for(int j=0; j<ga; j++){
            if( arr[i][j]==1 ){
                qu.push({i, j});
                arr[i][j] = cnt;
                while( !qu.empty() ){
                    now = qu.front();
                    qu.pop();
                    for(int k=0; k<4; k++){
                        next = fmove(now, k);
                        if( next.r==-1 ) continue;
                        if( arr[next.r][next.c]==0 ) continue;
                        if( arr[next.r][next.c]==cnt ) continue;
                        qu.push(next);
                        arr[next.r][next.c] = cnt;
                    }
                }
                cnt++;
            }
        }
    }
    nodes = cnt-2;
}

void make_edges(){
    int state, pre,now,distance,island_num;
    for(int k=0; k<2; k++){
        for(int i=0; i<se; i++){
            state = 0;
            if( k==0 ) pre = arr[i][0];
            else pre = arr[0][i];
            for(int j=1; j<ga; j++){
                if( k==0 ) now = arr[i][j];
                else now = arr[j][i];
                if( pre>0 && now==0 ){
                    state = 1;
                    distance = 1;
                    island_num = pre;
                }else if( state==1 ){
                    if( now>0 ){
                        state = 0;
                        if( island_num!=now && distance>1 ){
                            edges[island_num].push_back({now, distance});
                            edges[now].push_back({island_num, distance});
                        }
                    }else distance++;
                }
                pre = now;
            }
        }
        int tmp=se;
        se = ga;
        ga = tmp;
    }
}

struct cmp{
    bool operator()(st a, st b){
        return a.w>b.w;
    }
};

void prim(){
    int visit[nodes+2];
    int chk[nodes+2];
    int goal=-1, sum=0;
    st now;
    priority_queue<st, vector<st>, cmp> qu2;

    for(int i=2; i<nodes+2; i++){
        visit[i] = 0;
        chk[i] = 100;
    }

    qu2.push({2, 0});
    while( !qu2.empty() ){
        now = qu2.top();
        qu2.pop();
        if( visit[now.node]==1 ) continue;
        visit[now.node] = 1;
        sum += now.w;
        goal++;
        for(st i : edges[now.node]){
            if( visit[i.node]==1 ) continue;
            if( chk[i.node]<i.w ) continue;
            qu2.push(i);
            chk[i.node] = i.w;
        }
        if( goal==nodes-1 ){
            printf("%d\n", sum);
            return;
        }
    }
    printf("-1\n");
}

int main(){
    scanf("%d %d", &se, &ga);
    for(int i=0; i<se; i++){
        for(int j=0; j<ga; j++){
            scanf("%d", &arr[i][j]);
        }
    }
    make_nodes();
    make_edges();
    prim();
    return 0;
}
```