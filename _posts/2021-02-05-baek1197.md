---
title: (백준)1197. 최소 스패닝 트리
author: rapidfe
date: 2021-02-07 15:41:00 +0900
categories: [알고리즘, c++]
tags: [백준, MST, 스터디 5주차]
math: true
---

# **문제**

---

> [https://www.acmicpc.net/problem/1197](https://www.acmicpc.net/problem/1197)



# **풀이**

---

문제 제목 그대로 MST를 구현하는 문제다.

Prim 알고리즘과 Kruskal 알고리즘 두 가지 모두 구현해보았다.

> [[MST 알고리즘을 참고한 블로그]](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html)

#### **오답 1**

continue문을 잘못 사용함.

#### **시간복잡도**

\\(N\\) = node의 수,   \\(E\\) = edge의 수

**1) Prim 알고리즘**

\\((\\) \\(N\times\\)최소 가중치 \\(edge\\)를 선택하는 시간  \\(+\\)  \\(E\times key\\)값을 갱신하는 시간 \\()\\)

최소 가중치 edge 선택의 구현 방법에 따라 달라진다.

- array로 구현: \\(O(N^2)\\)
- heap으로 구현: \\(O(ElogN)\\)

> [[Prim 알고리즘 시간복잡도 참고 블로그 1]](https://victorydntmd.tistory.com/102)
>
> [[Prim 알고리즘 시간복잡도 참고 블로그 2]](https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm)

**2) Kruskal 알고리즘**





# **코드**

---

```c++
#include <stdio.h>
#include <queue>

using namespace std;

typedef struct{int r,c;}coo;
typedef struct{int node,w;}st;
int ga,se,nodes;
int arr[10][10];
int dr[] = {0,1,0,-1}, dc[] = {1,0,-1,0};
queue<coo> qu;
vector<st> edges[8];

coo fmove(coo now, int dir){
    now.r += dr[dir];
    now.c += dc[dir];
    if( now.r<0 || now.r==se || now.c<0 || now.c==ga )
        now.r = -1;
    return now;
}

void make_nodes(){
    int cnt = 2;
    coo now,next;
    for(int i=0; i<se; i++){
        for(int j=0; j<ga; j++){
            if( arr[i][j]==1 ){
                qu.push({i, j});
                arr[i][j] = cnt;
                while( !qu.empty() ){
                    now = qu.front();
                    qu.pop();
                    for(int k=0; k<4; k++){
                        next = fmove(now, k);
                        if( next.r==-1 ) continue;
                        if( arr[next.r][next.c]==0 ) continue;
                        if( arr[next.r][next.c]==cnt ) continue;
                        qu.push(next);
                        arr[next.r][next.c] = cnt;
                    }
                }
                cnt++;
            }
        }
    }
    nodes = cnt-2;
}

void make_edges(){
    int state, pre,now,distance,island_num;
    for(int k=0; k<2; k++){
        for(int i=0; i<se; i++){
            state = 0;
            if( k==0 ) pre = arr[i][0];
            else pre = arr[0][i];
            for(int j=1; j<ga; j++){
                if( k==0 ) now = arr[i][j];
                else now = arr[j][i];
                if( pre>0 && now==0 ){
                    state = 1;
                    distance = 1;
                    island_num = pre;
                }else if( state==1 ){
                    if( now>0 ){
                        state = 0;
                        if( island_num!=now && distance>1 ){
                            edges[island_num].push_back({now, distance});
                            edges[now].push_back({island_num, distance});
                        }
                    }else distance++;
                }
                pre = now;
            }
        }
        int tmp=se;
        se = ga;
        ga = tmp;
    }
}

struct cmp{
    bool operator()(st a, st b){
        return a.w>b.w;
    }
};

void prim(){
    int visit[nodes+2];
    int chk[nodes+2];
    int goal=-1, sum=0;
    st now;
    priority_queue<st, vector<st>, cmp> qu2;

    for(int i=2; i<nodes+2; i++){
        visit[i] = 0;
        chk[i] = 100;
    }

    qu2.push({2, 0});
    while( !qu2.empty() ){
        now = qu2.top();
        qu2.pop();
        if( visit[now.node]==1 ) continue;
        visit[now.node] = 1;
        sum += now.w;
        goal++;
        for(st i : edges[now.node]){
            if( visit[i.node]==1 ) continue;
            if( chk[i.node]<i.w ) continue;
            qu2.push(i);
            chk[i.node] = i.w;
        }
        if( goal==nodes-1 ){
            printf("%d\n", sum);
            return;
        }
    }
    printf("-1\n");
}

int main(){
    scanf("%d %d", &se, &ga);
    for(int i=0; i<se; i++){
        for(int j=0; j<ga; j++){
            scanf("%d", &arr[i][j]);
        }
    }
    make_nodes();
    make_edges();
    prim();
    return 0;
}
```

